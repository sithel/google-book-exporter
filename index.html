<html>
  <head>
    <script src="//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.5.2/underscore-min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script> 
    <script type="text/javascript">
      var CLIENT_ID = '476088429836-dojf7c6dnrea0r04itdfic4r3fknlqn0.apps.googleusercontent.com';

      // The Browser API key obtained from the Google Developers Console.
      // Replace with your own Browser API key, or your own key.
      var DEVELOPER_KEY = 'AIzaSyBw_RU5aiiK4VgKpb0ypx_S9oLtx0S5LzM';

      // Replace with your own App ID. (Its the first number in your Client ID)
      var APP_ID = "476088429836";

      var SCOPES = [
          'https://www.googleapis.com/auth/drive.file',
          'https://www.googleapis.com/auth/drive',
          'email',
          'profile',
          // Add other scopes needed by your application.
        ];

      var oauthToken;
      var comments;


      /**
       * Check if the current user has authorized the application.
       */
      function checkAuth() {
        console.log("in check auth");
        gapi.auth.authorize(
            {'client_id': CLIENT_ID, 'scope': SCOPES, 'immediate': true},
            handleAuthResult);
      }

      /**
       * Called when authorization server replies.
       *
       * @param {Object} authResult Authorization result.
       */
      function handleAuthResult(authResult) {
        console.log("in auth result : ", authResult);
        if (authResult && !authResult.error) {
          console.log(">> yay");
          oauthToken = authResult.access_token;
          createPicker();
          // Access token has been successfully retrieved, requests can be sent to the API
        } else {
          console.log(">> nay");
          // No access token could be retrieved, force the authorization flow.
          gapi.auth.authorize(
              {'client_id': CLIENT_ID, 'scope': SCOPES, 'immediate': false},
              handleAuthResult);
          oauthToken = authResult.access_token;
          createPicker();
        }
      }

        /**
         * Print a file's metadata.
         *
         * @param {String} fileId ID of the file to print metadata for.
         */
         // 1XniQSnkhjSJQhbReAOhPvqXenZzIf0Aika5gyhUz7nc  is id?
        function printFile(fileId) {
          console.log("in print File ", fileId);

          gapi.client.load('drive', 'v2', function() {
            console.log("in the drive loaded-ness...?");

            var request = gapi.client.drive.files.get({
                'fileId': fileId
            });
            request.execute(function(resp) {
              console.log("in the execute callback");
              if (!resp.error) {
                console.log(">> yay file!! ");
                console.log('Title: ' + resp.title);
                console.log('Description: ' + resp.description);
                console.log('MIME type: ' + resp.mimeType);
                console.log('exportLinks: ' + resp.exportLinks);
                console.log("the whole thing... \n", resp);
                downloadFile(resp.exportLinks['text/html'], handle_raw_content);
              } else if (resp.error.code == 401) {
                console.log(" >> 401 file");
                // Access token might have expired.
                checkAuth();
              } else {
                console.log('An error occured: ' + resp.error.message);
              }
            });


            var request = gapi.client.drive.comments.list({
                'fileId': fileId
            });
            request.execute(function(resp) {
              console.log("in the comment execute callback");
              if (!resp.error) {
                console.log(">> yay comment!! ");
                console.log("the whole thing... \n", resp);
                comments = resp.items;
                if (resp.nextPageToken) {
                  grab_even_more_comments(fileId, resp.nextPageToken);
                }
              } else if (resp.error.code == 401) {
                console.log(" >> 401 file");
                // Access token might have expired.
                checkAuth();
              } else {
                console.log('An error occured: ' + resp.error.message);
              }
            });


          });
        }

        function grab_even_more_comments(fileId, nextPageToken) {
            var request = gapi.client.drive.comments.list({
                'fileId': fileId,
                'pageToken': nextPageToken
            });
            // request.setPageToken(nextPageToken);
            request.execute(function(resp) {
              console.log("even more comments...");
              if (!resp.error) {
                console.log("the next batch... \n", resp);
                comments = comments.concat(resp.items);
                latexItSafely();
                if (resp.nextPageToken) {
                  grab_even_more_comments(fileId, resp.nextPageToken);
                }
              } else if (resp.error.code == 401) {
                console.log(" >> 401 file");
                // Access token might have expired.
                checkAuth();
              } else {
                console.log('An error occured: ' + resp.error.message);
              }
            });
        }

        function handle_raw_content(x) {
          console.debug("OH SHIT!! I JUST GOT : ",x);
          $('.guts').html(x);
          latexItSafely();
        }
        function downloadFile(url, callback) {
          if (url) {
            var accessToken = gapi.auth.getToken().access_token;
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url);
            xhr.setRequestHeader('Authorization', 'Bearer ' + accessToken);
            xhr.onload = function() {
              callback(xhr.responseText);
            };
            xhr.onerror = function() {
              callback(null);
            };
            xhr.send();
          } else {
            callback(null);
          }
        }


        // Create and render a Picker object for searching images.
        function createPicker() {
          // console.log("Grabbing test document");
          // printFile('1XniQSnkhjSJQhbReAOhPvqXenZzIf0Aika5gyhUz7nc');
          // return

          console.log("Grabbing session 38");
          printFile('1bhrOjaW_1b3fNcN4aXkuUDb9nLKYSJewSYoIo3zXVc8');
          return

          
          // USE THE STUFF BELOW HERE TO ACTUALLY PICK UP THE ID
          console.log("about to pick something w/ ", oauthToken);
          if (pickerApiLoaded && oauthToken) {
            var view = new google.picker.View(google.picker.ViewId.DOCS);
            // view.setMimeTypes("image/png,image/jpeg,image/jpg");
            view.setMimeTypes("application/vnd.google-apps.document");
            var picker = new google.picker.PickerBuilder()
                .enableFeature(google.picker.Feature.NAV_HIDDEN)
                .enableFeature(google.picker.Feature.MULTISELECT_ENABLED)
                .setAppId(APP_ID)
                .setOAuthToken(oauthToken)
                .addView(view)
                .addView(new google.picker.DocsUploadView())
                // .setDeveloperKey(DEVELOPER_KEY)
                .setCallback(pickerCallback)
                .build();
             picker.setVisible(true);
          }
        }

        // A simple callback implementation.
        function pickerCallback(data) {
          console.log(" 'sup callback? ", data);
          if (data.action == google.picker.Action.PICKED) {
            var fileId = data.docs[0].id;
            console.log('The user selected: ' + fileId);
            printFile(fileId)
          }
        }

        function onPickerApiLoad() {
          pickerApiLoaded = true;
          createPicker();
        }
        function onClientLoad() {
          console.log("... loaded the client library?");
        }

      function loadPicker() {
        console.log(" > load picker....");
        gapi.load('auth', {'callback': checkAuth});
        gapi.load('client', {'callback': onClientLoad});
        gapi.load('picker', {'callback': onPickerApiLoad});
      }
      function latex_scrub_str(text) {
          var orig_text = text;
          // handle underscores?
          text = text.replace(/_/g, "\\_")
          text = text.replace(/\[/g, "{[}")
          text = text.replace(/&/g, "\\&")
          text = text.replace(/]/g, "{]}")

          text = text.replace(/’/g, "'")
          text = text.replace(/\u2018/g, "'")
          text = text.replace(/\u2019/g, "'")
          
          text = text.replace(/“/g, "``")
          text = text.replace(/\“/g, "``")
          text = text.replace(/\u201c/g, "``")

          text = text.replace(/”/g, "''")
          text = text.replace(/\”/g, "''")
          text = text.replace(/\"/g, "''")
          text = text.replace(/\u201d/g, "''")

          text = text.replace(/\u2026/g, "...")

          text = text.replace(/</g, "\\textless ")
          text = text.replace(/>/g, "\\textgreater ")
          if (orig_text != text) {
            console.debug("we just scrubbed "+ text);
          }
          return text;
      }

      function inject_footnote_pre_markup(copy){
        var com_i = 1;
        while (copy.find('[name=cmnt_ref'+com_i+']').length) {
          var ref_el = copy.find('[name=cmnt_ref'+com_i+']');
          var footnote = copy.find('[name=cmnt'+com_i+']').parent().find('span').text();
          var possible_content = ref_el.parent().prev()
          var comment = find_comment(footnote, possible_content);
          if (comment) {
            console.log("rebecca, you rock!");
            footnote = mark_up_comment(footnote, comment);
            attempt_to_highlight(comment, ref_el, possible_content);
          } else {
            console.warn("no love for '"+footnote+"'");
          }
          ref_el.parent().prepend(footnote);  // neither footnote nor orig content has been scrubbed yet
          ref_el.remove();
          ++com_i;
        }
      }

      function latexIt() {
        var backup = $('.guts').clone();
        var copy = $('.guts');

        inject_footnote_pre_markup(copy);

        copy.find('span').each(function(i, x) {
          var el = $(x);
          var text = $(x).text();
          el.text(latex_scrub_str(text));
        });
        copy.find('a').each(function(i, x) {
          var el = $(x);
          var text = $(x).text();
          el.text(latex_scrub_str(text));
        });
        copy.find('sup').each(function(i, x) {
          var el = $(x);
          var text = $(x).text();
          el.text(latex_scrub_str(text));
        });

        console.log("we're checking the font/color for "+copy.find('span').length)
        copy.find('span').each(function(i, x) {
          var el = $(x);
          if (! el.text()) {
            return;
          }
          color_array = el.css('color').match(/rgb\((\d*), (\d*), (\d*)\)/);  // r = 1, g = 2, b = 3
          if (color_array && color_array[1] + color_array[2] + color_array[3] > 0) {
            color_str = color_array[1]+","+color_array[2]+","+color_array[3];
            console.debug("just colored '"+el.text()+"'")
            el.text(" {\\color[RGB]{"+color_str+"}"+el.text()+"} ");
          }
          if (el.css("font-weight") == "bold") {
            console.debug("just bolded '"+el.text()+"'")
            el.text("\\textbf{"+el.text()+"}");
          }
          if (el.css("font-style") == "italic") {
            console.debug("just italicized '"+el.text()+"'")
            el.text("\\textit{"+el.text()+"}");
          }
          var font_size_str = el.css('font-size');
          if (font_size_str && parseInt(font_size_str.substring(0, font_size_str.length - 2)) > 14) {
            size = parseInt(font_size_str.substring(0, font_size_str.length - 2))
            console.debug("making the text HUGE because size is "+size+": "+el.text());
            el.text(" {\\huge "+el.text()+" } ");
          }

          if (el.css('text-align') == "center") {
            el.text("\\begin{center}\n"+el.text()+"\n\\end{center}\n");
          }
        });



        result = ""
        console.log("going to pick up... "+copy.find('>p').length);
        copy.find('>p').each(function(i, x){
          var el = $(x)
          var text = el.text();
          result = result + text + "\n\n";
        })
        result = repair_pre_markups(result);
        result =  "\\documentclass[11pt]{amsart}\n"+
          "\\usepackage{color}\n"+
          "\\usepackage{soul}\n"+
          "\\setlength{\\parindent}{1cm} % Default is 15pt\n"+
          "\\setlength{\\parskip}{1cm plus4mm minus3mm}\n"+
          "\\begin{document}\n" + result + "\n" + "\\end{document}"
        $('.latex').text(result);
        // $('.guts').html(backup.html())
      }
      latexItSafely = _.debounce(latexIt, 10000);

      function find_comment(footnote, possible_content) {
        // TODO : doesn't handle the duplicate footnote issues
        // No scrubbing here because it happens PRE scrubbing
        footnote = footnote.replace(/\u00A0/g, " ");
        console.log("Looking for footnote '"+footnote+"' --- ")
        return _.reduce(comments, function(memo, c) {
          if (memo) {
            return memo;
          }
          if (c.content == footnote) {
            return c;
            console.log("  >> MATCHES!");
          }
          console.log("  >> does NOT match '"+c.content+"'")
          return _.find(c.replies, function(r) {
            r.isReply = true;
            if (r.content == footnote) {
               return true;
               console.log("    >>>> MATCHES!");
            } else {
              console.log("    >>>> does NOT match reply '"+r.content+"'");
            }
            return r.content == footnote;
          });
        }, null);
      }
      function repair_pre_markups(result) {
        result = result.replace(/REBECCAxxBEGINxxFOOTNOTExxBASICxx(.*?)xxHERExxISxxTHExxFOOTNOTExx(.*?)xxHERExxISxxTHExxDATExx(.*?)xxENDxxFOOTNOTE/g, 
          " \\footnote{ \\textbf { $1 } $2 \\textsubscript{$3}} ")
        result = result.replace(/REBECCAxxBEGINxxFOOTNOTExxREPLYxx(.*?)xxHERExxISxxTHExxFOOTNOTExx(.*?)xxHERExxISxxTHExxDATExx(.*?)xxENDxxFOOTNOTE/g, 
          " \\footnote{ $\\rightarrow$ \\textbf { $1 } $2 \\textsubscript{$3}} ")
        result = result.replace(/REBECCAxxBEGINxxHIGHLIGHTxx(.*?)xxENDxxHIGHLIGHT/g, 
          " \\hl{ $1 } ")
        return result;
      }
      function mark_up_comment(footnote, comment) {
        if (comment.isReply) {
          // return "$\\rightarrow$ \\textbf { "+comment.author.displayName +" } "+footnote +" \\textsubscript { "+comment.createdDate+" } ";
          return "REBECCAxxBEGINxxFOOTNOTExxREPLYxx"+comment.author.displayName+"xxHERExxISxxTHExxFOOTNOTExx"+footnote+"xxHERExxISxxTHExxDATExx"+comment.createdDate+"xxENDxxFOOTNOTE";
        }
        return "REBECCAxxBEGINxxFOOTNOTExxBASICxx"+comment.author.displayName+"xxHERExxISxxTHExxFOOTNOTExx"+footnote+"xxHERExxISxxTHExxDATExx"+comment.createdDate+"xxENDxxFOOTNOTE";
        // return "\\textbf { "+comment.author.displayName +" } "+footnote +" \\textsubscript { "+comment.createdDate+" } ";
      }
      function attempt_to_highlight(comment, ref_el, possible_content) {
        if (!comment.context || !comment.context.value) {
          return;
        }
        if (possible_content.text().replace(/\u00A0/g, " ") == comment.context.value) {
          possible_content.text("REBECCAxxBEGINxxHIGHLIGHTxx"+possible_content.text()+"xxENDxxHIGHLIGHT");
          // possible_content.text(" \\hl{ "+possible_content.text()+" } ");
        } else {
          console.warn("I didn't mush because I've got `"+possible_content.text()+"` vs `"+comment.context.value+"`");
          debugger;
        }

      }

    </script>
    <script type="text/javascript" src="https://apis.google.com/js/api.js?onload=loadPicker"></script>
    

    <title>REB TEST</title>
  </head>
  <body>
    <!-- YOUR CONTENT -->
    Yo dawg, what's up?<br>
    <div onclick="createPicker()">DO IT AGAIN</div>
    <br>
    <textarea class="latex" style="margin: 0px; width: 1000px; height: 300px;"></textarea> 
    <hr>
    <div class="guts"></div>
  </body>
</html>